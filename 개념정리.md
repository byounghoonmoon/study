# Java 정리

## String, StringBuffer, StringBuilder 
  |분류|String|StringBuffer|StringBuilder
  |:--:|:--:|:--:|:--:|
  |변경|Immutable|mutable|mutable
  |동기화||Synchronized Tread-Safe|Synchronized 불가 
  
  - String 클래스 : 문자열 연산이 적고, 조회가 많은 멀티쓰레드 환경에서 좋음
  - StringBuffer 클래스 : 문자열 연산이 많은 Multi-Thread 환경
  - StringBuilder 클래스 : 문자열 연산이 많은 Single-Thread 또는 Thread 신경 안쓰는 환경

----

## Stream API  
  - 특징
    - 원본의 데이터 변경 X
    - 일회용 (두번 사용 X)
    - 내부 반복작업으로 처리
    - 코드 간결성


## 함수형 인터페이스  
  - Supplier< T >  
    - 특징 : 매개변수 X, 반환값 O     
    - 예시 
        ```java
        Supplier<String> sup = ()->"Hello";
        System.out.println(sup.get());
        ```
  - Consumer< T >
  - Function< T, R >
  - Predicate< T >

## Optional Class
  - Null 이 올 수 있는 값은 감싸는 Wrapper Class 
  - NPE(Null Point Exception) 예방


## Spring
  - @RestController
    ```java
        @RestController
        @RequestMapping("/user")
        @RequiredArgsConstructor
        public class UserController {
            private final UserService userService;

            @PostMapping(value = "/info1")
            public ResponseEntity<User> info1(@RequestBody User user) {
                return ResponseEntity.ok(userService.retrieveUserInfo(user));
            }

            @PostMapping(value = "/info2")
            public ResponseEntity<User> info2(@RequestParam(value = "userName", required = true) String userName) {
                User user = userService.retrieveUserInfo(userName);
                if (user == null) {
                    return ResponseEntity.noContent().build()
                } return ResponseEntity.ok(user)
            }

            @PostMapping(value = "/info3")
            public ResponseEntity<User> info3(@RequestParam(value = "userName", required = true) String userName) {
                return Optional.ofNullable(userService.retrieveUserInfo(userName)).map(user -> ResponseEntity.ok(user)).orElse(ResponseEntity.noContent().build());
            }
        }
    ```
  - dd